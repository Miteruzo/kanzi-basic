;*******************************************************************************
; ワﾟイル名  : main.hsp
; 更新年月日 : 平30/10/28
; 作成者     : Taker32X
; 作成年月日 : 平30/04/24
; 機能       : 漢字 BASIC のインタプリタ
;*******************************************************************************

;----------------------------------- 須爲事 -----------------------------------
;
; 一，作FOR，GOSUB．
;
; 二，作可書文窓．
;
; 三，作可畫幕．
;
;------------------------------------------------------------------------------

#const MAJOR_VER 0
#const MINOR_VER 0
#const PATCH_VER 0
#const BUILD_NUM 838
#define PROJECT_NAME ("kb")
#define PROJECT_FILE ("main.hsp")

#addition "../mod_taker.as

#packopt hide 1
#packopt version "version_kb.txt
#packopt upx "0
#packopt lang "1041

#uselib "user32
#cfunc GetWindowLong "GetWindowLongA" int,int
#func SetWindowLong "SetWindowLongA" int,int,int
#cfunc IsZoomed "IsZoomed" int
#cfunc IsIconic "IsIconic" int
#func CreatePopupMenu "CreatePopupMenu"
#func AppendMenu "AppendMenuA" sptr,sptr,sptr,sptr
#func TrackPopupMenu "TrackPopupMenu" sptr,sptr,sptr,sptr,sptr,sptr,sptr
#func DestroyMenu "DestroyMenu" sptr

#uselib "kernel32
#func Beep "Beep" int,int

#uselib "gdi32
#func GetTextExtentPoint32 "GetTextExtentPoint32A" int,var,int,var

#uselib "imm32
#cfunc ImmCreateContext "ImmCreateContext"
#cfunc ImmAssociateContext "ImmAssociateContext" int,int
#func ImmSetCompositionWindow "ImmSetCompositionWindow" int,var,int
#func ImmGetCompositionString "ImmGetCompositionStringA" int,int,var,int
#func ImmSetCompositionFont "ImmSetCompositionFontA" int,var
#func ImmReleaseContext "ImmReleaseContext" int,int
#func ImmDestroyContext "ImmDestroyContext" int
#cfunc ImmGetContext "ImmGetContext" int

#uselib "footy2
#func Footy2Create "Footy2Create" int,int,int,int,int,int
#func Footy2Delete "Footy2Delete" int
#func Footy2TextFromFile "Footy2TextFromFileA" int,sptr,int
#func Footy2AddEmphasis "Footy2AddEmphasisA" int,sptr,sptr,int,int,int,int,int,int
#func Footy2FlushEmphasis "Footy2FlushEmphasis" int

#const global SIZE_X 8
#const global SIZE_Y 16

#const global MAX_X 240
#const global MAX_Y 80

#const global KEY_BS $08
#const global KEY_RETURN $0D
#const global KEY_SHIFT $10
#const global KEY_CTRL $11
#const global KEY_LEFT $25
#const global KEY_UP $26
#const global KEY_RIGHT $27
#const global KEY_DOWN $28
#const global KEY_INS $2D
#const global KEY_DEL $2E
#const global KEY_F1 $70
#const global KEY_F2 $71
#const global KEY_F3 $72
#const global KEY_F4 $73
#const global KEY_F5 $74
#const global KEY_F6 $75
#const global KEY_F7 $76
#const global KEY_F8 $77
#const global KEY_F9 $78
#const global KEY_F10 $79
#const global KEY_F11 $7A
#const global KEY_F12 $7B

#define ctype InKey(%1) If ((key_(%1)==0||key_(%1)>=32)&&key_(%1)\3==0&&key(%1))

#enum global WINDOW_MAIN=0
#enum global WINDOW_FULL
#enum global WINDOW_CONSOLE
#enum global WINDOW_GRAPHIC
#enum global WINDOW_EDIT
#enum global WINDOW_PARAMETER
#enum global WINDOW_FREE	; 一番下に置く事．

#enum global CALC_PLUS=1
#enum global CALC_MINUS
#enum global CALC_TIMES
#enum global CALC_DIV
#enum global CALC_EQUAL
#enum global CALC_NOT_EQUAL
#enum global CALC_GREAT
#enum global CALC_LESS
#enum global CALC_GREAT_EQUAL
#enum global CALC_LESS_EQUAL
#enum global CALC_FRACT

#enum global ERROR_NONE=0
#enum global ERROR_SYNTAX
#enum global ERROR_FOUND_NOT_FILE
#enum global ERROR_TYPE_MISMATCH
#enum global ERROR_FOUND_NOT_LINE
#enum global ERROR_ZERO_DIV

#enum global MENU_MAIN=0
#enum global MENU_FILE
#enum global MENU_EDIT
#enum global MENU_VIEW
#enum global MENU_CONTROL

#enum global COMMAND_MENUBAR=1
#enum global COMMAND_TOOLBAR
#enum global COMMAND_QUIT
#enum global COMMAND_NEW
#enum global COMMAND_LOAD
#enum global COMMAND_SAVE
#enum global COMMAND_STATUSBAR
#enum global COMMAND_RUN

#module

#uselib "kernel32
#func Beep "Beep" int,int

#uselib "user32
#func DestroyMenu "DestroyMenu" sptr
#cfunc GetWindowLong "GetWindowLongA" int,int
#func SetWindowLong "SetWindowLongA" int,int,int
#func SetWindowPos "SetWindowPos" sptr,sptr,sptr,sptr,sptr,sptr,sptr
#cfunc GetSystemMenu "GetSystemMenu" int,nullptr
#func DeleteMenu "DeleteMenu" int,int,nullptr
#func EnableWindow "EnableWindow" int,int

#deffunc OnDisplay str p1
	work_len=p1
	Repeat StrLen(work_len)
		If cursor_x@+cnt>=(ginfo_winx/SIZE_X@){
			cursor_x@=-cnt
			cursor_y@+
		}
		If cnt+cursor_x@<0{
			cursor_x@=0
		}
		data@(cnt+cursor_x@,cursor_y@)=Peek(work_len,cnt)or(color_r@<<8)or(color_g@<<16)or(color_b@<<24)
	Loop
	Return

#deffunc local ChangeCalcMode
	If minus{
		line_num=-line_num
		line_1st=-line_1st
		minus=0
	}
	decimal=0
	Switch calc_mode
		Case CALC_PLUS
			number_god+line_num+line_1st
			SwBreak
		Case CALC_MINUS
			number_god-(line_num+line_1st)
			SwBreak
		Case CALC_TIMES
			number_god*(line_num+line_1st)
			SwBreak
		Case CALC_DIV
			If (line_num+line_1st){
				number_god/(line_num+line_1st)
			}Else{
				error=ERROR_ZERO_DIV
			}
			SwBreak
		Case CALC_EQUAL
			number_god=Double(number_god==line_num+line_1st)
			SwBreak
		Case CALC_NOT_EQUAL
			number_god=Double(number_god!=line_num+line_1st)
			SwBreak
		Case CALC_GREAT
			number_god=Double(number_god>line_num+line_1st)
			SwBreak
		Case CALC_LESS
			number_god=Double(number_god<line_num+line_1st)
			SwBreak
		Case CALC_GREAT_EQUAL
			number_god=Double(number_god>=line_num+line_1st)
			SwBreak
		Case CALC_LESS_EQUAL
			number_god=Double(number_god<=line_num+line_1st)
			SwBreak
		Case CALC_FRACT
			number_god=(line_num+line_1st)/number_god
			SwBreak
		Default
			number_god=line_num+line_1st
			SwBreak
	SwEnd
	line_1st=0.
	line_num=0.
	Return

#deffunc local CalcFunction
	Switch StrMid(reading,j,4)
		Case "正弦"
			line_num=Sin(line_num+line_1st)
			line_1st=0.
			j+2
			SwBreak
		Case "餘弦"
			line_num=Cos(line_num+line_1st)
			line_1st=0.
			j+2
			SwBreak
		Case "正接"
			line_num=Tan(line_num+line_1st)
			line_1st=0.
			j+2
			SwBreak
		Case "符號"
			If line_num+line_1st>0{
				line_num=1.
			}Else: If line_num+line_1st<0{
				line_num=-1.
			}Else{
				line_num=0.
			}
			line_1st=0.
			j+2
			SwBreak
	SwEnd
	Switch StrMid(reading,j,2)
		Case "亂"
			line_num=Double(Rnd(line_num+line_1st))
			line_1st=0.
			SwBreak
	SwEnd
	Switch StrMid(reading,j,6)
		Case "平方根"
			line_num=SqRt(line_num+line_1st)
			line_1st=0.
			j+4
			SwBreak
		Case "立方根"
			line_num=PowF(line_num+line_1st,1./3)
			line_1st=0.
			j+4
			SwBreak
		Case "絶対値"
			line_num=AbsF(line_num+line_1st)
			line_1st=0.
			j+4
			SwBreak
	SwEnd
	Return

#defcfunc Kan2Arabia str p1
	reading=p1
	line_1st=0.
	line_num=0.
	number_god=0.
	calc_mode=0
	minus=0
	decimal=0
	Repeat memory_num@
		Split reading,memory_name@(cnt),left_man
		right_man(cnt)=StrLen(left_man)
	Loop
	For j,0,StrLen(reading),2
		Repeat 9
			If StrMid(reading,j,2)==number@(cnt){
				If decimal{
					line_1st+PowF(10,-decimal)*(cnt+1)
					decimal+
				}Else{
					line_1st=Double(cnt+1)
				}
				Break
			}
		Loop
		Repeat 3
			If StrMid(reading,j,2)==number@(cnt+9){
				line_num+((line_1st+(line_1st==0))*(cnt+1))*10
				line_1st=0.
				Break
			}
		Loop
		Repeat 2
			If StrMid(reading,j,2)==number@(cnt+12){
				line_num+(line_1st+(line_1st==0))*Int(PowF(10,cnt+2))
				line_1st=0.
				Break
			}
		Loop
		Repeat 12
			If StrMid(reading,j,2)==number@(cnt+14){
				line_num=(line_num+line_1st+(line_num+line_1st==0))*PowF(10000,cnt+1)
				line_1st=0.
				Break
			}
		Loop
		Switch StrMid(reading,j,6)
			Case "不等於"
				ChangeCalcMode
				calc_mode=CALC_NOT_EQUAL
				j+4
				SwBreak
			Case "圓周率"
				line_num=M_PI
				line_1st=0.
				j+4
				SwBreak
		SwEnd
		Switch StrMid(reading,j,4)
			Case "乘以"
				ChangeCalcMode
				calc_mode=CALC_TIMES
				j+2
				SwBreak
			Case "除以"
				ChangeCalcMode
				calc_mode=CALC_DIV
				j+2
				SwBreak
			Case "等於"
				Switch calc_mode
					Case CALC_GREAT
						calc_mode=CALC_GREAT_EQUAL
						SwBreak
					Case CALC_LESS
						calc_mode=CALC_LESS_EQUAL
						SwBreak
					Default
						ChangeCalcMode
						calc_mode=CALC_EQUAL
						SwBreak
				SwEnd
				j+2
				SwBreak
			Case "大於"
				ChangeCalcMode
				calc_mode=CALC_GREAT
				j+2
				SwBreak
			Case "小於"
				ChangeCalcMode
				calc_mode=CALC_LESS
				j+2
				SwBreak
			Case "分之"
				ChangeCalcMode
				calc_mode=CALC_FRACT
				j+2
				_Continue
				SwBreak
		SwEnd
		Switch StrMid(reading,j,2)
			Case "加"
				ChangeCalcMode
				calc_mode=CALC_PLUS
				SwBreak
			Case "減"
				ChangeCalcMode
				calc_mode=CALC_MINUS
				SwBreak
			Case "零"
			Case "〇"
				If decimal{
					decimal+
				}Else{
					line_num=0.
					line_1st=0.
				}
				SwBreak
			Case "之"
				j+2
				CalcFunction
				SwBreak
			Case "負"
				minus=1
				SwBreak
			Case "度"
				line_num=Deg2Rad(line_num+line_1st)
				line_1st=0.
				SwBreak
			Case "π"
			Case "兀"
				line_num=M_PI
				line_1st=0.
				SwBreak
			Case "ｅ"
				line_num=2.7182818284590452354
				line_1st=0.
				SwBreak
			Case "點"
				decimal=1
				SwBreak
		SwEnd
		Repeat memory_num@
			If j==right_man(cnt){
				line_num=0.
				line_1st=memory_data@(cnt)
				j+StrLen(memory_name@(cnt))-2
				Break
			}
		Loop
	Next
	ChangeCalcMode
	Return number_god

#defcfunc Arabia2Kan double p1
	work_num=p1
	If p1<200000{
		work_num2=StrF("%.300g",p1)
	}Else{
		work_num2=StrF("%.300e",p1)
		Split work_num2,"e",work_num2
		If stat>1{
			work_num2(0)=StrTrim(work_num2(0),2,'0')+"e"+work_num2(1)
		}
	}
	If InStr(work_num2,0,"e")==-1{
		If work_num<0{
			number_pay="負
		}Else{
			number_pay=""
		}
		work_num=AbsF(work_num)
		If 0.<=work_num&&work_num<1{
			number_pay+"零
		}Else{
			work_digit=Int(LogF(work_num)/LogF(10)+0.0000001)+1
			Repeat work_digit
				If work_num/PowF(10,work_digit-cnt-1)\10==0{
					If (work_digit-cnt-1)\4==0{
						Switch (work_digit-cnt-1)/4
							Case 1
								Repeat 14
									If StrMid(number_pay,StrLen(number_pay)-2,2)==number@(cnt){
										number_pay+"萬
										Break
									}
								Loop
								SwBreak
							Case 2
								Repeat 15
									If StrMid(number_pay,StrLen(number_pay)-2,2)==number@(cnt){
										number_pay+"億
										Break
									}
								Loop
								SwBreak
							Case 3
								Repeat 16
									If StrMid(number_pay,StrLen(number_pay)-2,2)==number@(cnt){
										number_pay+"兆
										Break
									}
								Loop
								SwBreak
							Case 4
								Repeat 17
									If StrMid(number_pay,StrLen(number_pay)-2,2)==number@(cnt){
										number_pay+"京
										Break
									}
								Loop
								SwBreak
							Case 5
								Repeat 18
									If StrMid(number_pay,StrLen(number_pay)-2,2)==number@(cnt){
										number_pay+"垓
										Break
									}
								Loop
								SwBreak
						SwEnd
					}
					Continue
				}
				If work_num/PowF(10,work_digit-cnt-1)\10>=2+((work_digit-cnt-1)\4==1)*2||(work_digit-cnt-1)\4==0{
					number_pay+number@(Int(work_num/PowF(10,work_digit-cnt-1)\10-1))
				}
				If (work_digit-cnt-1)\4{
					Switch (work_digit-cnt-1)\4
						Case 1
							Switch Int(work_num/PowF(10,work_digit-cnt-1)\10)
								Case 2
									If Int(work_num/PowF(10,work_digit-cnt-2)\10)==0{
										number_pay+"二十
									}Else{
										number_pay+"廿
									}
									SwBreak
								Case 3
									If Int(work_num/PowF(10,work_digit-cnt-2)\10)==0{
										number_pay+"三十
									}Else{
										number_pay+"卅
									}
									SwBreak
								Default
									If Int(work_num/PowF(10,work_digit-cnt-2)\100)==10{
										number_pay+"一
									}
									number_pay+"十
									SwBreak
							SwEnd
							SwBreak
						Case 2
							If Int(work_num/PowF(10,work_digit-cnt-3)\1000)==100{
								number_pay+"一
							}
							number_pay+"百
							SwBreak
						Case 3
							If Int(work_num/PowF(10,work_digit-cnt-4)\10000)==1000{
								number_pay+"一
							}
							number_pay+"千
							SwBreak
					SwEnd
				}Else{
					Switch (work_digit-cnt-1)/4
						Case 1
							number_pay+"萬
							SwBreak
						Case 2
							number_pay+"億
							SwBreak
					SwEnd
				}
			Loop
		}
	}Else{
		work_num_=work_num
		work_num2_=work_num2
		number_pay_=number_pay
		number_pay=Arabia2Kan(Int(work_num2))
		work_num=work_num_
		work_num2=work_num2_
	}
	If number_pay==""||number_pay=="負"{
		number_pay+"零
	}
	Split work_num2,".",work_num2
	If stat>1{
		number_pay+"點
		Repeat StrLen(work_num2(1))
			Switch StrMid(work_num2(1),cnt,1)
				Case "0"
					number_pay+"零
					SwBreak
				Case "e"
					work_num_=work_num
					work_num2_=work_num2
					work_num2_(1)=work_num2(1)
					number_pay_=number_pay
					number_pay_+"乘以一十之"+Arabia2Kan(Int(StrMid(work_num2(1),cnt+1,StrLen(work_num2(1))-(cnt+1))))+"次方
					work_num=work_num_
					work_num2=work_num2_
					work_num2(1)=work_num2_(1)
					number_pay=number_pay_
					Break
					SwBreak
				Default
					number_pay+number@(Int(StrMid(work_num2(1),cnt,1))-1)
					SwBreak
			SwEnd
		Loop
	}
	StrRep number_pay,"點乘","乘
	Return number_pay

#defcfunc GetKey2 int p1
	GetKey key,p1
	Return key

#deffunc CheckSentence str p1
	string=p1
	error=ERROR_SYNTAX
	reading="
	For i,0,StrLen(string)
		reading+StrMid(string,i,1)
		Switch reading
			Case "滅幕"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				If work==""{
					work="一"
				}
				If Int(Kan2Arabia(work))and 1{
					Repeat MAX_X*MAX_Y
						data@(cnt\MAX_X,cnt/MAX_X)=0
					Loop
					gSel WINDOW_CONSOLE
					Color 0,0,0
					BoxF
					If mode_full@{
						gSel WINDOW_FULL
					}Else{
						gSel WINDOW_MAIN
					}
					cursor_x@=0
					cursor_y@=0
					error=0
				}
				If Int(Kan2Arabia(work))and 2{
					gSel WINDOW_GRAPHIC
					ClS 4
					If mode_full@{
						gSel WINDOW_FULL
					}Else{
						gSel WINDOW_MAIN
					}
					error=0
				}
				SwBreak
			Case "言"
			Case "云"
			Case "謂"
			Case "曰"
			Case "記"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				carry=0
				If StrMid(work,StrLen(work)-2,2)=="續"{
					work=StrMid(work,0,StrLen(work)-2)
					carry=1
				}
				Split work,"「",work
				If stat>1{
					Split work(1),"」",work
					OnDisplay work(0)
					If carry{
						cursor_x@+StrLen(work(0))
						If cursor_x@>=ginfo_winx/SIZE_X{
							cursor_y@+
							cursor_x@\(ginfo_winx/SIZE_X)
						}
					}Else{
						cursor_y@+
					}
				}Else: If StrMid(work,0,2)=="文"{
					ForEach program@
						If program@(cnt)!=""{
							OnDisplay program@(cnt)
							cursor_y@+
						}
					Loop
				}Else: If StrMid(work,0,2)=="書"{
					DirList work2,"*.*"
					NoteSel work2
						Repeat notemax
							NoteGet work3,cnt
							OnDisplay work3
							cursor_y@+
						Loop
					NoteUnsel
				}Else: If work!=""{
					If Kan2Arabia(work)
					If error!=ERROR_ZERO_DIV{
						OnDisplay Arabia2Kan(Kan2Arabia(work))
						If carry{
							cursor_x@+StrLen(Arabia2Kan(Kan2Arabia(work)))
							If cursor_x@>=ginfo_winx/SIZE_X{
								cursor_y@+cursor_x@/(ginfo_winx/SIZE_X)
								cursor_x@\(ginfo_winx/SIZE_X)
							}
						}Else{
							cursor_y@+
						}
					}Else: _Break
				}
				error=0
				SwBreak
			Case "色是"
				work=Int(Kan2Arabia(StrMid(string,i+1,StrLen(string)-(i+1))))
				color_r@=(work and 2)*255
				color_g@=(work and 4)*255
				color_b@=(work and 1)*255
				error=0
				SwBreak
			Case "鳴"
				Beep 880,500
				error=0
				SwBreak
			Case "走"
				run_mode@=1
				run_line@=0
				error=0
				SwBreak
			Case "終"
				run_mode@=0
				error=0
				SwBreak
			Case "退"
				ForEach hwnd_menu@
					DestroyMenu hwnd_menu@(cnt)
				Loop
				End
			Case "去"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				run_line@=Int(Kan2Arabia(work))-2
				run_mode@=1
				error=0
				SwBreak
			Case "幅是"
				Width Int(Kan2Arabia(StrMid(string,i+1,StrLen(string)-(i+1))))*SIZE_X+gosa_x@,ginfo_winy+gosa_y@
				error=0
				SwBreak
			Case "高是"
				Width ginfo_winx+gosa_x@,Int(Kan2Arabia(StrMid(string,i+1,StrLen(string)-(i+1))))*SIZE_Y+gosa_y@
				error=0
				SwBreak
			Case "讀"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				Split work,"「",work
				If stat>1{
					Split work(1),"」",work
					Exist work(0)
					If strsize!=-1{
						sDim work2,256*Length(program@)
						bLoad work(0),work2
						ForEach program@
							MemCpy program@(cnt),work2,256,0,256*cnt
						Loop
						error=0
					}Else{
						error=ERROR_FOUND_NOT_FILE
					}
				}
				SwBreak
			Case "書"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				Split work,"「",work
				If stat>1{
					Split work(1),"」",work
					sDim work2,256*Length(program@)
					ForEach program@
						MemCpy work2,program@(cnt),256,256*cnt
					Loop
					bSave work(0),work2
					error=0
				}Else{
					error=ERROR_FOUND_NOT_FILE
				}
				SwBreak
			Case "滅文"
				sDim program@,256,65529
				error=0
				SwBreak
			Case "畫"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				If StrMid(work,0,4)=="點於"{
					work=StrMid(work,4,StrLen(work)-4)
					Split work,"與",work
					Repeat 2
						If StrMid(work(cnt),0,4)=="緯是"{
							graph_x@=Int(Kan2Arabia(StrMid(work(cnt),4,StrLen(work(cnt))-4)))
						}Else: If StrMid(work(cnt),0,4)=="經是"{
							graph_y@=Int(Kan2Arabia(StrMid(work(cnt),4,StrLen(work(cnt))-4)))
						}
					Loop
					gSel WINDOW_GRAPHIC
					Color color_r@,color_g@,color_b@
					pSet graph_x@,graph_y@
					If mode_full@{
						gSel WINDOW_FULL
					}Else{
						gSel WINDOW_MAIN
					}
					error=0
				}Else: If StrMid(work,0,4)=="線於"{
					work=StrMid(work,4,StrLen(work)-4)
					Split work,"从",work_start
					Split work,"到",work_end
					Split work_start(1),"與",work_start
					SPlit work_start(1),"到",work_start(1)
					Split work_end(1),"與",work_end
					Split work_end(1),"从",work_end(1)
					Repeat 2
						If StrMid(work_start(cnt),0,4)=="緯是"{
							graph_x@=Int(Kan2Arabia(StrMid(work_start(cnt),4,StrLen(work_start(cnt))-4)))
						}Else: If StrMid(work_start(cnt),0,4)=="經是"{
							graph_y@=Int(Kan2Arabia(StrMid(work_start(cnt),4,StrLen(work_start(cnt))-4)))
						}
					Loop
					gSel WINDOW_GRAPHIC
					Color color_r@,color_g@,color_b@
					Line graph_x@,graph_y@,graph_x@,graph_y@
					Repeat 2
						If StrMid(work_end(cnt),0,4)=="緯是"{
							graph_x@=Int(Kan2Arabia(StrMid(work_end(cnt),4,StrLen(work_end(cnt))-4)))
						}Else: If StrMid(work_end(cnt),0,4)=="經是"{
							graph_y@=Int(Kan2Arabia(StrMid(work_end(cnt),4,StrLen(work_end(cnt))-4)))
						}
					Loop
					Line graph_x@,graph_y@
					pSet graph_x@,graph_y@
					If mode_full@{
						gSel WINDOW_FULL
					}Else{
						gSel WINDOW_MAIN
					}
					error=0
				}Else: If StrMid(work,0,4)=="圓於"{
					
				}Else{
					Split work,"「",work
					If stat>1{
						Split work(1),"」",work
						Exist work(0)
						If strsize!=-1{
							gSel WINDOW_GRAPHIC
							PicLoad work(0),1
							If mode_full@{
								gSel WINDOW_FULL
							}Else{
								gSel WINDOW_MAIN
							}
							error=0
						}Else{
							error=ERROR_FOUND_NOT_FILE
						}
					}
				}
				SwBreak
			Case "編輯"
				gSel WINDOW_EDIT,1
				If mode_full@{
					gSel WINDOW_FULL
				}Else{
					gSel WINDOW_MAIN
				}
				error=0
				SwBreak
			Case "於"
			Case "于"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				Split work,"與",work
				Repeat 2
					If StrMid(work(cnt),0,4)=="緯是"{
						cursor_x@=Int(Kan2Arabia(StrMid(work(cnt),4,StrLen(work(cnt))-4)))
					}Else: If StrMid(work(cnt),0,4)=="經是"{
						cursor_y@=Int(Kan2Arabia(StrMid(work(cnt),4,StrLen(work(cnt))-4)))
					}
				Loop
				error=0
				SwBreak
			Case "若"
			Case "如"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
				Split work,"則",work(0),work(1)
				If stat<=1{
					Split work,"即",work(0),work(1)
					If stat<=1{
						Split work,"乃",work(0),work(1)
					}
				}
				Split work(1),"不然",work(1),work(2)
				If Int(Kan2Arabia(work(0))){
					string=work(1)
				}Else{
					If work(2)==""{
						error=0
					}
					string=work(2)
				}
				reading="
				i=-1
				_Continue
				SwBreak
			Case "滅腦"
				memory_num@=0
				sDim memory_name@,256,1
				dDim memory_data@,1
				error=0
				SwBreak
			Case "收"
;				data_read@=
				data_read_num@+
				SwBreak
			Case "拔"
				SwBreak
			Case "憶畫"
				work=StrMid(string,i+1,StrLen(string)-(i+1))
					Split work,"「",work
					If stat>1{
						Split work(1),"」",work
						Exist work(0)
						If strsize!=-1{
							Buffer WINDOW_FREE+data_graphic@
							PicLoad work(0)
							data_graphic@+
							If mode_full@{
								gSel WINDOW_FULL
							}Else{
								gSel WINDOW_MAIN
							}
							error=0
						}Else{
							error=ERROR_FOUND_NOT_FILE
						}
					}
				SwBreak
		SwEnd
	Next
	If error==ERROR_SYNTAX{
		Split string,"是",work_pi,work_wei
		If stat>1{
			flag=0
			If StrMid(work_pi,StrLen(work_pi)-2,2)=="弗"{
				Split work_wei,"「",work_wei
				Split work_wei(1),"」",work_wei
				Repeat memory_num_s@
					If memory_name_s@(cnt)==work_pi{
						memory_data_s@(cnt)=work_wei
						flag=1
						Break
					}
				Loop
				If flag==0{
					memory_name_s@(memory_num_s@)=work_pi
					memory_data_s@(memory_num_s@)=work_wei
					memory_num_s@+
				}
			}Else{
				Repeat memory_num@
					If memory_name@(cnt)==work_pi{
						memory_data@(cnt)=Kan2Arabia(work_wei)
						flag=1
						Break
					}
				Loop
				If flag==0{
					memory_name@(memory_num@)=work_pi
					memory_data@(memory_num@)=Kan2Arabia(work_wei)
					memory_num@+
				}
			}
			error=0
		}
	}
	Switch error
		Case ERROR_NONE
			SwBreak
		Case ERROR_SYNTAX
			Beep 880,500
			If run_mode@{
				OnDisplay "第"+work_line@+"有不正文。
			}Else{
				OnDisplay "有不正文。
			}
			cursor_y@+
			cursor_x@=0
			SwBreak
		Case ERROR_FOUND_NOT_FILE
			Beep 880,500
			If run_mode{
				OnDisplay "其書於"+work_line@+"不知。
			}Else{
				OnDisplay "其書不知也。
			}
			cursor_y@+
			cursor_x@=0
			SwBreak
		Case ERROR_TYPE_MISMATCH
			Beep 880,500
			OnDisplay "有不適値。
			cursor_y@+
			cursor_x@=0
			SwBreak
		Case ERROR_ZERO_DIV
			Beep 880,500
			OnDisplay "被除以零。
			cursor_y@+
			cursor_x@=0
			SwBreak
		Default
			Beep 880,500
			If run_mode@{
				OnDisplay "生未知誤於"+work_line@+"。
			}Else{
				OnDisplay "生未知誤。
			}
			cursor_y@+
			cursor_x@=0
			SwBreak
	SwEnd
	Return error

#deffunc Command int p1
	Switch p1
		Case COMMAND_MENUBAR
			Dialog "Test.
			SwBreak
		Case COMMAND_QUIT
			ForEach hwnd_menu@
				DestroyMenu hwnd_menu@(cnt)
			Loop
			End
			SwBreak
		Case COMMAND_NEW
			OnDisplay "滅文。
			cursor_y@+
			CheckSentence "滅文
			OnDisplay "好。
			cursor_y@+
			SwBreak
		Case COMMAND_LOAD
			OnDisplay "讀「
			cursor_x@+4
			SetDialog 320,120
			Color 240,240,240
			BoxF
			read_file="
			Input read_file,200,24
			box_id=stat
			ObjSize 64,24
			Button GoSub "参照...",*Refer
			Button GoSub "OK",*Ok
			gSel WINDOW_PARAMETER,1
			If mode_full@{
				gSel WINDOW_FULL
			}Else{
				gSel WINDOW_MAIN
			}
			EnableWindow hwnd,0
			SwBreak
		Case COMMAND_SAVE
			SwBreak
		Case COMMAND_RUN
			OnDisplay "走。
			cursor_y@+
			CheckSentence "走
			SwBreak
	SwEnd
	Return

*Ok
	gSel WINDOW_PARAMETER,-1
	If mode_full@{
		gSel WINDOW_FULL,1
	}Else{
		gSel WINDOW_MAIN,1
	}
	EnableWindow hwnd,1
	OnDisplay read_file+"」。
	cursor_x@=0
	cursor_y@+
	CheckSentence "讀「"+read_file
	OnDisplay "好。
	cursor_y@+
	Return

*Refer
	gSel WINDOW_PARAMETER
	Dialog,16
	If stat{
		read_file=refstr
		ObjPrm box_id,read_file
	}
	If mode_full@{
		gSel WINDOW_FULL
	}Else{
		gSel WINDOW_MAIN
	}
	Return

#deffunc SetDialog int p1,int p2
	Screen WINDOW_PARAMETER,p1,p2,SCREEN_HIDE or SCREEN_FIXEDSIZE
	SetWindowLong hwnd,-16,GetWindowLong(hwnd,-16)and$70000 xor GetWindowLong(hwnd,-16)
	SetWindowLong hwnd,-8,hwnd_list@(mode_full@)
	SetWindowPos hwnd,0,0,0,0,0,39
	DeleteMenu GetSystemMenu(hwnd),$F000
	DeleteMenu GetSystemMenu(hwnd),$F020
	DeleteMenu GetSystemMenu(hwnd),$F030
	DeleteMenu GetSystemMenu(hwnd),$F120
	Return

#global

	Buffer WINDOW_GRAPHIC,Limit(ginfo_dispx,SIZE_X,MAX_X*SIZE_X),Limit(ginfo_dispy,SIZE_Y,MAX_Y*SIZE_Y)
	ClS 4
	Buffer WINDOW_CONSOLE,Limit(ginfo_dispx,SIZE_X,MAX_X*SIZE_X),Limit(ginfo_dispy,SIZE_Y,MAX_Y*SIZE_Y)
	ClS 4
	Font MSMINCHO,SIZE_Y
	sDim program,256,65529
	GoSub *BuildEditor
	bgScr WINDOW_FULL,Limit(ginfo_dispx,SIZE_X,MAX_X*SIZE_X),Limit(ginfo_dispy,SIZE_Y,MAX_Y*SIZE_Y),SCREEN_HIDE,0,0,ginfo_dispx,ginfo_dispy
	hwnd_ime(1)=ImmGetContext(hwnd)
	hwnd_list(1)=hwnd
	ClS 4
	Screen WINDOW_MAIN,Limit(ginfo_dispx,SIZE_X,MAX_X*SIZE_X),Limit(ginfo_dispy,SIZE_Y,MAX_Y*SIZE_Y),SCREEN_HIDE
	SetWindowLong hwnd,-16,GetWindowLong(hwnd,-16)or$50000
	Width 640,400
	gosa_x=640-ginfo_winx
	gosa_y=400-ginfo_winy
	Width 640+gosa_x,400+gosa_y
	hwnd_ime(0)=ImmGetContext(hwnd)
	hwnd_list(0)=hwnd
	Dim key,256
	Dim data,MAX_X,MAX_Y
	Dim data_work,MAX_X,MAX_Y
	number="一","二","三","四","五","六","七","八","九","十","廿","卅","百","千","萬","億","兆","京","垓","杼","穣","溝","澗","正","載","極
	through="　"," "
	replace_from="与","読","画","点","経","従","從","続","乗","万","余","乱","円","号
	replace_to  ="與","讀","畫","點","經","從","从","續","乘","萬","餘","亂","圓","號
	CreatePopupMenu
	hwnd_menu(MENU_MAIN)=stat
	CreatePopupMenu
	hwnd_menu(MENU_FILE)=stat
	CreatePopupMenu
	hwnd_menu(MENU_EDIT)=stat
	CreatePopupMenu
	hwnd_menu(MENU_VIEW)=stat
	CreatePopupMenu
	hwnd_menu(MENU_CONTROL)=stat
	AppendMenu hwnd_menu(MENU_MAIN),$10,hwnd_menu(MENU_FILE),"&F/ワﾟィル
	AppendMenu hwnd_menu(MENU_FILE),0,COMMAND_NEW,"&N/新規作成
	AppendMenu hwnd_menu(MENU_FILE),0,COMMAND_LOAD,"&L/読込...
	AppendMenu hwnd_menu(MENU_FILE),0,COMMAND_SAVE,"&S/保存...
	AppendMenu hwnd_menu(MENU_MAIN),$10,hwnd_menu(MENU_EDIT),"&E/編輯
	AppendMenu hwnd_menu(MENU_MAIN),$10,hwnd_menu(MENU_VIEW),"&V/表示
	AppendMenu hwnd_menu(MENU_MAIN),$10,hwnd_menu(MENU_CONTROL),"&C/制禦
	AppendMenu hwnd_menu(MENU_CONTROL),0,COMMAND_RUN,"&R/プログラムの実行
	AppendMenu hwnd_menu(MENU_CONTROL),0,COMMAND_BREAK,"&B/プログラムの停止
	AppendMenu hwnd_menu(MENU_MAIN),$800,0,""
	AppendMenu hwnd_menu(MENU_MAIN),0,COMMAND_QUIT,"&Q/終了\tGRPH+f･4
	AppendMenu hwnd_menu(MENU_VIEW),0,COMMAND_MENUBAR,"&M/メニュゥ・バァ
	AppendMenu hwnd_menu(MENU_VIEW),0,COMMAND_TOOLBAR,"&T/ツゥル・バァ
	AppendMenu hwnd_menu(MENU_VIEW),0,COMMAND_STATUSBAR,"&S/スティタス・バァ
	OnClick GoSub *Popup
	OnExit GoSub *Vofari
	ClS 4
	If mode_full{
		gSel WINDOW_FULL,1
	}Else{
		gSel WINDOW_MAIN,1
	}
	Dim logfont,20
	logfont(0)=SIZE_Y
	Poke logfont,23,1
	font_name=MSMINCHO
	MemCpy logfont,font_name,strlen(font_name),28,0
	Font MSMINCHO,SIZE_Y
	color_r=0:color_g=255:color_b=255
	OnDisplay "漢字 BASIC −培基君− ("+VERSION_NUMBER+" 號)
	cursor_y+
	OnDisplay "(C)松田有著作權於平成三十年
	cursor_y+
	OnDisplay "能用 "+VarSize(program)*Length(program)+" 字
	cursor_y+
	color_r=255:color_g=255:color_b=255
	OnDisplay "備好。
	cursor_x=0:cursor_y+2

*Main
	ime_text_="
	Repeat
		If ginfo_act==WINDOW_MAIN||ginfo_act==WINDOW_FULL{
			ImmSetCompositionFont hwnd_ime(mode_full),logfont
		}
		If IsIconic(hwnd)==0{
			If ginfo_winy<SIZE_Y{
				Width ginfo_winx+gosa_x,SIZE_Y+gosa_y
			}
			If IsZoomed(hwnd)==0||mode_full==0{
				work_x=ginfo_winx:work_y=ginfo_winy
				If work_x\SIZE_X{
					work_x=(work_x+SIZE_X/2)/SIZE_X*SIZE_X
				}
				If work_y\SIZE_Y{
					work_y=(work_y+SIZE_Y/2)/SIZE_Y*SIZE_Y
				}
				If ginfo_winx!=work_x||ginfo_winy!=work_y{
					Width work_x+gosa_x,work_y+gosa_y
				}
			}
			If run_mode==0{
				ReDraw 0
				Color 0,0,0
				BoxF
				gMode 2
				Pos 0,0
				gCopy WINDOW_GRAPHIC,0,0,ginfo_winx,ginfo_winy
				Pos 0,0
				gCopy WINDOW_CONSOLE,0,0,ginfo_winx,ginfo_winy
				If ginfo_act==WINDOW_MAIN||ginfo_act==WINDOW_FULL{
					form=2,cursor_x*SIZE_X,cursor_y*SIZE_Y
					ImmSetCompositionWindow hwnd_ime(mode_full),form
					ime_text_=ime_text
					ime_text="
					ImmGetCompositionString hwnd_ime(mode_full),8,ime_text,str_size2
					str_size2=stat
					sDim ime_text,str_size2+1
					ImmGetCompositionString hwnd_ime(mode_full),8,ime_text,str_size2
				}
			}
			If GetKey2(KEY_F11)!=0&&f11_remember==0{
				If mode_full{
					gSel WINDOW_FULL,-1
					gSel WINDOW_MAIN,1
					mode_full=0
				}Else{
					gSel WINDOW_MAIN,-1
					gSel WINDOW_FULL,1
					mode_full=1
				}
			}
			f11_remember=GetKey2(KEY_F11)
			If run_mode{
				Repeat
					If run_line>=65529{
						OnDisplay "好。
						cursor_y+
						cursor_x=0
						run_mode=0
						run_line=0
						Break
					}
					If run_line>=0{
						If program(run_line)==""{
							run_line+
						}Else{
							Break
						}
					}
				Loop
				If run_mode==0{
					Continue
				}
				Split program(run_line),"，",sentence
				stat_=stat
				work_line=sentence(0)
				sentence=sentence(1)
				Repeat stat_-2,2
					sentence+"，"+sentence(cnt)
				Loop
				GoSub *Check
				If error{
					run_mode=0
				}
				If GetKey2(KEY_CTRL)!=0&&GetKey2('C')!=0{
					GoSub *Vofari
				}
				run_line+
			}Else{
				Repeat 256
					If key(cnt){
						key_(cnt)+
					}Else{
						key_(cnt)=0
					}
					GetKey key(cnt),cnt
					If ginfo_act!=WINDOW_MAIN&&ginfo_act!=WINDOW_FULL{
						key(cnt)=0
					}
					If ime_text_==""&&ime_text==""&&key(KEY_CTRL)==0{
						If (key_(cnt)==0||key_(cnt)>=' ')&&key_(cnt)\3==0&&('0'<=cnt&&cnt<='Z'||cnt==' ')&&key(cnt)!=0&&key($F3)!=0{
							Pos cursor_x*SIZE_X,cursor_y*SIZE_Y
							data(cursor_x,cursor_y)=(cnt+('A'<=cnt&&cnt<='Z'&&key(KEY_SHIFT)==0)*('a'-'A'))or(color_r<<8)or(color_g<<16)or(color_b<<24)
							cursor_x+
							If cursor_x>=ginfo_winx/SIZE_X{
								cursor_x=0
								cursor_y+
							}
						}
						If key(cnt)&&(key_(cnt)==0||key_(cnt)>=48)&&($08<=cnt&&cnt<=$7F){
							blink=0
						}
					}
				Loop
				If ime_text_==""&&ime_text==""{
					InKey(KEY_RETURN){
						sentence="
						Repeat MAX_X
							If (data(cnt,cursor_y)and$FF)==0{
								Break
							}
							sentence+StrF("%c",data(cnt,cursor_y)and$FF)
						Loop
						cursor_x=0
						cursor_y+
						Split sentence,"「",work_a
						stat_=stat
						ForEach through
							StrRep work_a(0),through(cnt),""
						Loop
						ForEach replace_from
							StrRep work_a(0),replace_from(cnt),replace_to(cnt)
						Loop
						sentence=work_a(0)
						Repeat stat_-1,1
							Split work_a(cnt),"」",work_b
							stat_=stat
							work_a(cnt)=work_b(0)
							cnt__=cnt
							Repeat stat_-1,1
								cnt_=cnt
								ForEach through
									StrRep work_b(cnt_),through(cnt),""
								Loop
								ForEach replace_from
									StrRep work_b(cnt_),replace_from(cnt),replace_to(cnt)
								Loop
								work_a(cnt__)+"」"+work_b(cnt)
							Loop
							sentence+"「"+work_a(cnt)
						Loop
						If sentence!=""{
							GoSub *Check
						}
					}Else: InKey(KEY_BS){
						cursor_x-
						If cursor_x<0{
							If cursor_y>0{
								cursor_x=ginfo_winx/SIZE_X-1
								cursor_y-
							}Else{
								cursor_x=0
							}
						}
						Repeat Length(data)-cursor_x-1,cursor_x
							data(cnt,cursor_y)=data(cnt+1,cursor_y)
						Loop
					}Else: InKey(KEY_DEL){
						cursor_x-
						If cursor_x<0: cursor_x=0
						Repeat Length(data)-cursor_x-1,cursor_x
							data(cnt,cursor_y)=data(cnt+1,cursor_y)
						Loop
					}Else: InKey(KEY_INS){
						Repeat ginfo_winx/SIZE_X-cursor_x
							data(ginfo_winx/SIZE_X-cnt,cursor_y)=data(ginfo_winx/SIZE_X-cnt-1,cursor_y)
						Loop
						data(cursor_x,cursor_y)=' '
					}Else: InKey(KEY_LEFT){
						cursor_x-
						If cursor_x>0{
							work=(data(cursor_x-1,cursor_y)and$FF)
							If $81<=work&&work<=$9F||($E0<=work&&work<=$FC){
								cursor_x-
							}
						}
						If cursor_x<0{
							If cursor_y>0{
								cursor_x=ginfo_winx/SIZE_X-1
								cursor_y-
							}Else{
								cursor_x=0
							}
						}
					}Else: InKey(KEY_UP){
						cursor_y-
						If cursor_y<0{
							cursor_y=0
						}
					}Else: InKey(KEY_RIGHT){
						cursor_x+
						If cursor_x<ginfo_winx/SIZE_X-1{
							work=(data(cursor_x-1,cursor_y)and$FF)
							If $81<=work&&work<=$9F||($E0<=work&&work<=$FC){
								cursor_x+
							}
						}
						If cursor_x>=ginfo_winx/SIZE_X{
							cursor_x=0
							cursor_y+
						}
					}Else: InKey(KEY_DOWN){
						cursor_y+
						If cursor_y>=ginfo_winy/SIZE_Y{
							cursor_y=ginfo_winy/SIZE_Y-1
						}
					}Else: If GetKey2(KEY_CTRL):InKey('C'){
						cursor_y+
						cursor_x=0
					}
				}
				If ginfo_act==WINDOW_MAIN||ginfo_act==WINDOW_FULL{
					ime_comp="
					s=0
					ImmGetCompositionString hwnd_ime(mode_full),$800,ime_comp,s
					s=stat
					sdim ime_comp,s+1
					ImmGetCompositionString hwnd_ime(mode_full),$800,ime_comp,s
					If s==0{
						ss=0
					}
					If s!=0&&ss==0{
						str1_=ime_comp
						ss=1
					}else{
						ime_comp="
					}
					If ime_text==""&&key($F3)==0: InKey(' '){
						ime_comp="　
					}
					OnDisplay ime_comp
					cursor_y+(cursor_x+StrLen(ime_comp))/(ginfo_winx/SIZE_X)
					cursor_x=(cursor_x+StrLen(ime_comp))\(ginfo_winx/SIZE_X)
				}
			}
			If cursor_y>=ginfo_winy/SIZE_Y{
				cursor_y-
				Repeat MAX_X*(MAX_Y-1)
					data(cnt\MAX_X,cnt/MAX_X)=data(cnt\MAX_X,cnt/MAX_X+1)
					data_work(cnt\MAX_X,cnt/MAX_X)=0
				Loop
				gSel WINDOW_CONSOLE
				Color 0,0,0
				BoxF
				If mode_full{
					gSel WINDOW_FULL
				}Else{
					gSel WINDOW_MAIN
				}
			}
			If run_mode==0{
				gSel WINDOW_CONSOLE
				Repeat ginfo_winx/SIZE_X*(ginfo_winy/SIZE_Y)
					work=Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X))*4)
					If data(cnt\(ginfo_winx/SIZE_X),cnt/(ginfo_winx/SIZE_X))!=data_work(cnt\(ginfo_winx/SIZE_X),cnt/(ginfo_winx/SIZE_X)){
						If full{
							Color 0,0,0
							BoxF cnt\(ginfo_winx/SIZE_X)*SIZE_X,cnt/(ginfo_winx/SIZE_X)*SIZE_Y,(cnt\(ginfo_winx/SIZE_X)+2)*SIZE_X-1,(cnt/(ginfo_winx/SIZE_X)+1)*SIZE_Y-1
							Color work_r,work_g,work_b
							Print StrF("%c%c",Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X)-1)*4),work)
							full=0
						}Else{
							Pos cnt\(ginfo_winx/SIZE_X)*SIZE_X,cnt/(ginfo_winx/SIZE_X)*SIZE_Y
							work_r=Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X))*4+1)
							work_g=Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X))*4+2)
							work_b=Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X))*4+3)
							If $81<=work&&work<=$9F||($E0<=work&&work<=$FC)&&Peek(data,(cnt/(ginfo_winx/SIZE_X)*MAX_X+cnt\(ginfo_winx/SIZE_X)+1)*4)!=0{
								full=1
							}Else{
								Color 0,0,0
								BoxF cnt\(ginfo_winx/SIZE_X)*SIZE_X,cnt/(ginfo_winx/SIZE_X)*SIZE_Y,(cnt\(ginfo_winx/SIZE_X)+1)*SIZE_X-1,(cnt/(ginfo_winx/SIZE_X)+1)*SIZE_Y-1
								Color work_r,work_g,work_b
								Print StrF("%c",work)
							}
						}
					}
				Loop
				If mode_full{
					gSel WINDOW_FULL
				}Else{
					gSel WINDOW_MAIN
				}
				MemCpy data_work,data,4*Length(data)*Length2(data)
			}
			If run_mode==0{
				If blink\32<16{
					work=Peek(data,(cursor_y*MAX_X+cursor_x)*4)
					If $81<=work&&work<=$9F||($E0<=work&&work<=$FC){
						Repeat SIZE_X*SIZE_Y*2
							pGet cursor_x*SIZE_X+cnt\(SIZE_X*2),cursor_y*SIZE_Y+cnt/(SIZE_X*2)
							Color 255-ginfo_r,255-ginfo_g,255-ginfo_b
							pSet cursor_x*SIZE_X+cnt\(SIZE_X*2),cursor_y*SIZE_Y+cnt/(SIZE_X*2)
						Loop
					}Else{
						Repeat SIZE_X*SIZE_Y
							pGet cursor_x*SIZE_X+cnt\SIZE_X,cursor_y*SIZE_Y+cnt/SIZE_X
							Color 255-ginfo_r,255-ginfo_g,255-ginfo_b
							pSet cursor_x*SIZE_X+cnt\SIZE_X,cursor_y*SIZE_Y+cnt/SIZE_X
						Loop
					}
				}
				blink+
				ReDraw 1
			}
		}
		If run_mode==0||cnt\1000==0{
			Wait 0	; コンピュータのばか!!
		}
	Loop
	Stop

*Check
	programming=0
	ForEach number
		If StrMid(sentence,0,2)==number(cnt){
			programming=1
			Break
		}
	Loop
	If programming{
		reading="
		For i,0,StrLen(sentence),2
			work=0
			ForEach number
				If StrMid(sentence,i,2)==number(cnt){
					reading+number(cnt)
					work=1
					Break
				}
			Loop
;			If Length(program)>Int(Kan2Arabia(reading))-1&&Int(Kan2Arabia(reading))-1>=0{
				If work==0{
					If StrMid(sentence,i,2)!="，"{
						program(Int(Kan2Arabia(reading))-1)=reading+"，"+StrMid(sentence,i,StrLen(sentence)-i)
					}Else{
						If reading+"，"==sentence{
							program(Int(Kan2Arabia(reading))-1)="
						}Else{
							program(Int(Kan2Arabia(reading))-1)=reading+StrMid(sentence,i,StrLen(sentence)-i)
						}
					}
					_Break
				}Else: If i==StrLen(sentence)-2{
					If reading==sentence||reading+"，"==sentence{
						program(Int(Kan2Arabia(reading))-1)=""
					}
				}
;			}Else{
;				error=ERROR_FOUND_NOT_LINE
;			}
		Next
	}Else{
		stat__=1
		stat_=1
		Split sentence,"「",work_a
		stat_=stat
		work_c=""
		Split work_a(0),"而",sentence
		sentence_num=stat-1
		Repeat stat_-1,1
			Split work_a(cnt),"」",work_b
			stat_=stat
			work_a(cnt)=work_b(0)
			cnt__=cnt
			Repeat stat_-1,1
				cnt_=cnt
				Split work_b(cnt),"而",work_c
				stat__=stat
				Repeat stat-1,1
					sentence(sentence_num+cnt)=work_c(cnt)
				Loop
				work_a(cnt__)+"」"+work_c(0)
			Loop
			sentence(sentence_num)+"「"+work_a(cnt)
			sentence_num+stat__-1
		Loop
		If Length(sentence)<=sentence_num{
			sentence(sentence_num)=""
		}
		Repeat sentence_num+1
			CheckSentence sentence(cnt)
			error=stat
			If error{
				Break
			}
		Loop
		If run_mode==0{
			OnDisplay "好。
			cursor_y+
			cursor_x=0
		}
	}
	Return
	Stop

*BuildEditor
	Screen WINDOW_EDIT,ginfo_dispx,ginfo_dispy,SCREEN_HIDE
	SetWindowLong hwnd,-16,GetWindowLong(hwnd,-16)or$50000
	Width 640,480
	MesBox program,640,480
	Return

*Vofari
	If lparam==0{
		Switch wparam
			Case WINDOW_MAIN
			Case WINDOW_FULL
				If run_mode{
					Beep 880,500
					OnDisplay "壞於"+work_line+"。
					cursor_x=0
					cursor_y+
					OnDisplay "好。
					cursor_y+
					cursor_x=0
					run_mode=0
				}Else{
					ForEach hwnd_menu
						DestroyMenu hwnd_menu(cnt)
					Loop
					End
				}
				SwBreak
			Case WINDOW_EDIT
				gSel WINDOW_EDIT,-1
				If mode_full{
					gSel WINDOW_FULL,1
				}Else{
					gSel WINDOW_MAIN,1
				}
				SwBreak
		SwEnd
	}
	Return

*Popup
	If wparam=2{
		TrackPopupMenu hwnd_menu(MENU_MAIN),$100,ginfo_mx,ginfo_my,0,hwnd,0
		Command stat
	}
	Return
