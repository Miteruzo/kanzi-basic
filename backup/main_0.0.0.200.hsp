;*******************************************************************************
; ワﾟイル名  : main.hsp
; 更新年月日 : 平30/04/24
; 作成者     : Taker32X
; 作成年月日 : 平30/04/24
; 機能       : 漢字 BASIC のインタプリタ
;*******************************************************************************

;------------------------------------ TODO ------------------------------------

;------------------------------------------------------------------------------

#const MAJOR_VER 0
#const MINOR_VER 0
#const PATCH_VER 0
#const BUILD_NUM 0
#define PROJECT_NAME ("xime")
#define PROJECT_FILE ("main.hsp")

#addition "../mod_taker.as

#module
#uselib "imm32.dll"
#cfunc ImmCreateContext "ImmCreateContext" 
#cfunc ImmAssociateContext "ImmAssociateContext" int, int
#func ImmSetCompositionWindow "ImmSetCompositionWindow" int,int,int 
#func ImmGetCompositionString "ImmGetCompositionStringA" int,int,var,int
#func ImmSetCompositionFont "ImmSetCompositionFontA" int,int
#func ImmReleaseContext "ImmReleaseContext" int,int
#func ImmDestroyContext "ImmDestroyContext" int
#cfunc ImmGetContext "ImmGetContext" int
 
//ウィンドウに関係づけられたIMEのハンドルを取得
#deffunc ime_hwnd int hwnd2_
defime=ImmGetContext(hwnd_2)
return defime
 
//ウィンドウにIMEを割り当て
#deffunc ime_creat int hwnd3_
hwnd_ime=ImmCreateContext()
k=ImmAssociateContext(hwnd3_,hwnd_ime)
return hwnd_ime
 
//IMEの出現場所指定 標準0,0
#deffunc ime_pos int hwnd2_ime,int com_posx, int com_posy
compositionform = 0x0002 ,com_posx ,com_posy
ImmSetCompositionWindow hwnd2_ime,varptr(compositionform)
return
 
//IMEに入力された決定文字を取得
#deffunc ime_getstr int hwnd2_ime,var buf,var str_size
str_size=0
ImmGetCompositionString hwnd2_ime,$800,buf,str_size
str_size=stat
sdim buf,str_size+1
ImmGetCompositionString hwnd2_ime,$800,buf,str_size
return
 
//IMEに入力された決定文字を取得　リアルタイム
#deffunc ime_getstr_rt int hwnd6_ime,var buf3
buf3=""
str_size2=0
ImmGetCompositionString hwnd6_ime,$8,buf3,str_size2
str_size2=stat
sdim buf3,str_size2+1
ImmGetCompositionString hwnd6_ime,$8,buf3,str_size2
return
 
//IMEフォント指定
#deffunc ime_font int hwnd4_ime,str font_name,int font_size
dim logfont,20
lfFaceName =font_name
logfont(0)=font_size
poke logfont,23,1
memcpy logfont, lfFaceName, strlen(lfFaceName), 28, 0
ImmSetCompositionFont hwnd4_ime,varptr(logfont)
return
 
//決定さてた文字を取得しやすくする
#deffunc ime_getstrex int hwnd3_ime,var buf2
ime_getstr hwnd3_ime,buf2,s
if s=0:ss=0
if s!0&&ss=0:str1_=buf:ss=1:else :buf2=""
return
 
//初期化簡略関数
#deffunc ime_ini int hwnd4_, var hwnd5_ime
ime_hwnd hwnd4_
hwnd5_ime=stat
if hwnd5_ime=0{
ime_creat hwnd4_
hwnd5_ime=stat
}
return
 
//ウィンドウに関係づけられたIMEを削除
#deffunc ime_dest int hwnd5_
ime_ini hwnd5_, hwnd6_ime
defime=ImmGetContext(hwnd5_)
if defime!0{
    ImmReleaseContext hwnd5_,defime
    ImmDestroyContext defime
}
return
#global

#module
#uselib "gdi32.dll"
#func GetTextExtentPoint32 "GetTextExtentPoint32A" int,int,int,int
#deffunc messize var tBuf,var tSizex,var tSizey
notesel tBuf
repeat notemax
noteget tBuf2,cnt
    tBuf3=tBuf2
    txtLen=strlen(tBuf3)
    dim tSize,2
    GetTextExtentPoint32 hdc,varptr(tBuf3),txtLen,varptr(tSize)
    if cnt=0:x=tSize(0)
    if x<tSize(0):x=tSize(0)
    loop
    tSize(0)=x
    tSize(1)=tSize(1)*notemax
    tSizex=tSize(0)
    tSizey=tSize(1)
    return
#global

#uselib "user32
#cfunc GetWindowLong "GetWindowLongA" int,int
#func SetWindowLong "SetWindowLongA" int,int,int

#const SIZE_X 8
#const SIZE_Y 16

#const MAX_X 240
#const MAX_Y 80

#define ctype InKey(%1) If ((key_(%1)==0||key_(%1)>=32)&&key_(%1)\3==0&&key(%1))

#enum WINDOW_MAIN=0

	Screen WINDOW_MAIN,Limit(ginfo_dispx,SIZE_X,MAX_X*SIZE_X),Limit(ginfo_dispy,SIZE_Y,MAX_Y*SIZE_Y),SCREEN_HIDE
	Width 640,400
	SetWindowLong hwnd,-16,GetWindowLong(hwnd,-16)or$50000
	ime_Ini hwnd,hwnd_ime
	Dim key,256
;	Dim data,ginfo_dispx/SIZE_X,ginfo_dispy/SIZE_Y
	sDim data,MAX_X*MAX_Y*4
	ClS 4
	gSel WINDOW_MAIN,1
	ime_Font hwnd_ime,MSMINCHO,SIZE_Y
	Font MSMINCHO,SIZE_Y
	work="漢字 BASIC −培基君− ("+VERSION_NUMBER+" 號)
	Repeat StrLen(work)
		Poke data,cnt*4,StrMid(work,cnt,1)
		Poke data,cnt*4+1,0
		Poke data,cnt*4+2,255
		Poke data,cnt*4+3,255
	Loop
	work="(C)Taker32X 有著作権於平成卅年
	Repeat StrLen(work)
		Poke data,(cnt+MAX_X)*4,StrMid(work,cnt,1)
		Poke data,(cnt+MAX_X)*4+1,0
		Poke data,(cnt+MAX_X)*4+2,255
		Poke data,(cnt+MAX_X)*4+3,255
	Loop
	work="準備好。
	Repeat StrLen(work)
		Poke data,(cnt+MAX_X*3)*4,StrMid(work,cnt,1)
		Poke data,(cnt+MAX_X*3)*4+1,255
		Poke data,(cnt+MAX_X*3)*4+2,255
		Poke data,(cnt+MAX_X*3)*4+3,255
	Loop
	cursor_x=0:cursor_y=4

*Main
	ime_text_="
	Repeat
		ReDraw 0
		Color 0,0,0
		BoxF
		ime_Pos hwnd_ime,cursor_x*SIZE_X,cursor_y*SIZE_Y
		ime_text_=ime_text
		ime_text="
		ime_GetStr_rt hwnd_ime,ime_text
		Repeat 256
			If key(cnt){
				key_(cnt)+
			}Else{
				key_(cnt)=0
			}
			GetKey key(cnt),cnt
			If ime_text_==""&&ime_text==""{
				If (key_(cnt)==0||key_(cnt)>=32)&&key_(cnt)\3==0&&('0'<=cnt&&cnt<='Z'||cnt==$20)&&key(cnt)&&key(243)!=0{
					Pos cursor_x*SIZE_X,cursor_y*SIZE_Y
					Poke data,(cursor_x+cursor_y*MAX_X)*4,cnt+('A'<=cnt&&cnt<='Z'&&key($10)==0)*('a'-'A')
					Poke data,(cursor_x+cursor_y*MAX_X)*4+1,255
					Poke data,(cursor_x+cursor_y*MAX_X)*4+2,255
					Poke data,(cursor_x+cursor_y*MAX_X)*4+3,255
					cursor_x+
					If cursor_x>=ginfo_winx/SIZE_X{
						cursor_x=0
						cursor_y+
					}
				}
				If key(cnt)&&(key_(cnt)==0||key_(cnt)>=48)&&($08<=cnt&&cnt<=$7F){
					blink=0
				}
			}
		Loop
		If ime_text_==""&&ime_text==""{
			InKey($0D){
				cursor_x=0
				cursor_y+
			}Else: InKey($08){
				cursor_x-
				If cursor_x<0: cursor_x=0
				Poke data,(cursor_x+cursor_y*MAX_X)*4,0
			}Else: InKey($25){
				cursor_x-
				If cursor_x<0{
					If cursor_y>0{
						cursor_x=ginfo_winx/SIZE_X-1
						cursor_y-
					}Else{
						cursor_x=0
					}
				}
			}Else: InKey($26){
				cursor_y-
				If cursor_y<0{
					cursor_y=0
				}
			}Else: InKey($27){
				cursor_x+
				If cursor_x>=ginfo_winx/SIZE_X{
					cursor_x=0
					cursor_y+
				}
			}Else: InKey($28){
				cursor_y+
				If cursor_y>=ginfo_winy/SIZE_Y{
					cursor_y=ginfo_winy/SIZE_Y-1
				}
			}
		}
		ime_GetStrEx hwnd_ime,ime_comp
		If ime_text==""&&key(243)!=0: InKey($20){
			ime_comp="　
		}
		Repeat StrLen(ime_comp)
			Poke data,(cnt+cursor_x+MAX_X*cursor_y)*4,StrMid(ime_comp,cnt,1)
			Poke data,(cnt+cursor_x+MAX_X*cursor_y)*4+1,255
			Poke data,(cnt+cursor_x+MAX_X*cursor_y)*4+2,255
			Poke data,(cnt+cursor_x+MAX_X*cursor_y)*4+3,255
		Loop
		cursor_y+(cursor_x+StrLen(ime_comp))/(ginfo_winx/SIZE_X)
		cursor_x=(cursor_x+StrLen(ime_comp))\(ginfo_winx/SIZE_X)
		If cursor_y>=ginfo_winy/SIZE_Y{
			Repeat MAX_X*(MAX_Y-1)
				cursor_y-
				lPoke data,cnt*4,lPeek(data,(MAX_X+cnt)*4)
			Loop
		}
		Repeat MAX_X*MAX_Y
			work=Peek(data,cnt*4)
			If work{
				If full{
					Print StrF("%c%c",Peek(data,(cnt-1)*4),work)
					full=0
				}Else{
					Pos cnt\MAX_X*SIZE_X,cnt/MAX_X*SIZE_Y
					Color Peek(data,cnt*4+1),Peek(data,cnt*4+2),Peek(data,cnt*4+3)
					If $81<=work&&work<=$9F||($E0<=work&&work<=$FC)&&Peek(data,(cnt+1)*4)!=0{
						full=1
					}Else{
						Print StrF("%c",work)
					}
				}
			}
		Loop
;		gSel WINDOW_COPY
;		gCopy WINDOW_MAIN,0,0,ginfo_dispx,ginfo_dispy
;		gSel WINDOW_MAIN
		If blink\32<16{
			Repeat SIZE_X*SIZE_Y
				pGet cursor_x*SIZE_X+cnt\SIZE_X,cursor_y*SIZE_Y+cnt/SIZE_X
				Color 255-ginfo_r,255-ginfo_g,255-ginfo_b
				pSet cursor_x*SIZE_X+cnt\SIZE_X,cursor_y*SIZE_Y+cnt/SIZE_X
			Loop
		}
		ReDraw 1
		blink+
		Await 15
	Loop
